# 光栅化直线

## 准备

我们先编写好创建ppm文件以及写入ppm文件的程序

我们将使用fstream读写ppm文件

```cpp
#include <iostream>
#include <fstream>
int main(){
    
    return 0;
}
```

定义好图片的尺寸以及分配颜色值的内存

```cpp
// 定义图片的尺寸
int width = 256;
int height = 256;

// 分配颜色值存储
int size = width * height;
int *r = new int[size];
int *g = new int[size];
int *b = new int[size];
```

size就是我们的像素个数，每个像素各自拥有rgb三个分量的颜色值，一共有size个像素，所以每个颜色值分量也就有size个

我们设置每个像素的颜色为红色

```cpp
  // 设置像素的颜色值
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            int idx = y * width + x;
            r[idx] = 255;
            g[idx] = 0;
            b[idx] = 0;
        }
    }
```

因为图片一般是由坐上角为原点，从左到右从上到下写数据的，所以我们也这样设置颜色值，如果不这样做到时候写入文件的时候像素就是乱的。

由于我们是用一维数组存放数据的，但是图片是二维的所以我们需要做一个简单的转化 y * width + x;

创建PPM文件

```cpp
    std::ofstream f("output.ppm");
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return 1;
    }
```

按照PPM格式P3模式写入文件

```cpp
 f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';
```

最后释放内存就好了

```cpp
	delete[] r;
    delete[] g;
    delete[] b;
```

此时代码是这样的

```cpp
#include <iostream>
#include <fstream>

int main()
{
    // 定义图片的尺寸
    int width = 256;
    int height = 256;

    // 分配颜色值存储
    int size = width * height;
    int *r = new int[size];
    int *g = new int[size];
    int *b = new int[size];

    // 设置像素的颜色值
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            int idx = y * width + x;
            r[idx] = 255;
            g[idx] = 0;
            b[idx] = 0;
        }
    }

    // 创建PPM文件
    std::ofstream f("output.ppm");
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return 1;
    }

    // 写入PPM文件
    f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';

    std::cout << "PPM image written to output.ppm" << std::endl;

    
    delete[] r;
    delete[] g;
    delete[] b;

    return 0;
}
```

![上程序渲染图片]()

### 优化

优化程序使其更易使用

```cpp
#include <iostream>
#include <string>
#include <fstream>

static const int width = 256;
static const int height = 256;
int size = width * height;

int *r = new int[size];
int *g = new int[size];
int *b = new int[size];

void SetPixel(int x, int y, int ColorR, int ColorG, int ColorB)
{
    int index = x + y * width;
    r[index] = ColorR;
    g[index] = ColorG;
    b[index] = ColorB;
}

bool Render(std::string filename)
{
    std::ofstream f(filename);
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return false;
    }

    f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';

    std::cout << "PPM image written to output.ppm" << std::endl;
    return true;
}

int main()
{

    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            SetPixel(x, y, 255, 0, 0);
        }
    }
    Render("output.ppm");

    delete[] r;
    delete[] g;
    delete[] b;
    return 0;
}
```

# **Bresenham** 画线算法

Bersenham画线算法的思想很简单，现在我们只讨论这种情况：

- 斜率存在且大于0
- 起点位置小于终点位置，也就是说起点距离原点的位置小于终点距离原点的位置
- 起点和终点坐标都是正整数

想想我们的目标是什么？我们的目标是将满足上述三个条件的连续线段用离散的像素拟合。

我们可以用解析几何的方式来拟合这条直线

若起点和终点分别为 $(x_1,y_1),(x_n,y_n)$ ,那么这条线段可以表示为
$$
y-y_1 = k(x-x_1)，y_1<y<y_n,x_1<x<x_n
$$
其中 $ k = \frac{y_n-y_1}{x_n-x_1}$

从中我们可以提取出什么信息呢？

$-y_1，-x_1$ 我们可以看作是吧线段的起点平移到左边原点

$k$ 可以翻译为 $x$ 增加 $dx$ 时 $y$ 增加 $kdx$

如果是离散的

$k$ 可以翻译为 $x$ 增加 1 时 $y$ 增加 $k$

那么我们可以写出如下的算法

- SetPixel($x_{1},y_{1}$)

- 当 $x_i\ne x_n$ 时
  - $x_{i+1} = x_i+1$
  - $y_{i+1} = y_i+k$
  - SetPixel($x_{i+1},y_{i+1}$)

我们试着用代码写出来

```cpp
#include <iostream>
#include <string>
#include <fstream>

static const int width = 256;
static const int height = 256;
int size = width * height;

int *r = new int[size];
int *g = new int[size];
int *b = new int[size];

void SetPixel(int x, int y, int ColorR, int ColorG, int ColorB)
{
    int index = x + y * width;
    r[index] = ColorR;
    g[index] = ColorG;
    b[index] = ColorB;
}

bool Render(std::string filename)
{
    std::ofstream f(filename);
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return false;
    }

    f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';

    std::cout << "PPM image written to output.ppm" << std::endl;
    return true;
}

void DrawLine(int x1, int y1, int xn, int yn, int r, int g, int b){
    double k = (yn - y1) / (xn - x1);
    int xi = x1;
    int yi = y1;
    SetPixel(x1, y1, r, g, b);
    while(xi!=xn){
        xi += 1;
        yi = yi+k;
        SetPixel(xi, yi, r, g, b);
    }
}
int main()
{

    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            SetPixel(x, y, 255, 255, 255);
        }
    }
    DrawLine(10,10,40,100,0,0,0);
    Render("output.ppm");

    delete[] r;
    delete[] g;
    delete[] b;
    return 0;
}
```

渲染图：

可以看到绘制出来的图片中的线的“不连续的”，为什么会这样呢

因为当我们对y的处理是直接越过 $y_i$ 到 $y_{i+1}$之间的所有点，直接只设置了$y_{i+1}$这一点的颜色值

那么我们怎么处理$y_i$ 到 $y_{i+1}$之间的点呢？很显然我们不能直接只设置$y_{i+1}$这一点的颜色值，我们需要对y也逐步设置就像x+=1一样，不过显然y是受k影响，的我们需要知道什么时候y应该+1什么时候+0，我们需要根据k来判断什么时候y应该+1还是+0

我们引入一个中间量来判断是否+1

我们让middle = 像素纵轴的中点，然后判断线段在该点处的y值是否大于middle 考虑y是否+1



